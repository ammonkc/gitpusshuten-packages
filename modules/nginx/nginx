#! /bin/sh

#------------------------------------------------------------------------------
#                               Functions
#------------------------------------------------------------------------------
. /lib/lsb/init-functions

#------------------------------------------------------------------------------
#                               Consts
#------------------------------------------------------------------------------
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=/opt/nginx/sbin/nginx

PS="nginx"
PIDNAME="nginx"				#Lets you do $PS-Master or $PS-Slave
PIDFILE=$PIDNAME.pid                    #pid file
PIDSPATH=/opt/nginx/logs
DESCRIPTION="Nginx Server..."

RUNAS=root				#user to run as

SCRIPT_OK=0				#ala error codes
SCRIPT_ERROR=1				#ala error codes
TRUE=1					#boolean
FALSE=0					#boolean

lockfile=/var/lock/subsys/nginx
NGINX_CONF_FILE="/opt/nginx/conf/nginx.conf"

#------------------------------------------------------------------------------
#                               Simple Tests
#------------------------------------------------------------------------------

#test if nginx is a file and executable
test -x $DAEMON || exit 0

# Include nginx defaults if available
if [ -f /etc/default/nginx ] ; then
        . /etc/default/nginx
fi

#set exit condition
#set -e

#------------------------------------------------------------------------------
#                               Functions
#------------------------------------------------------------------------------

setFilePerms(){

        if [ -f $PIDSPATH/$PIDFILE ]; then
                chmod -f 400 $PIDSPATH/$PIDFILE
        fi
}

configtest() {
	$DAEMON -t -c $NGINX_CONF_FILE
}

getPSCount() {
	return `pgrep -f $PS | wc -l`
}

isRunning(){
	pidof_daemon
	PID=$?

	if [ $PID -gt 0 ]; then
		return 1
        else
                return 0
        fi
}

status(){
	isRunning
	isAlive=$?

	if [ "${isAlive}" -eq $TRUE ]; then
                echo "$PIDNAME found running with processes:  `pidof $PS`"
        else
                echo "$PIDNAME is NOT running."
        fi


}

removePIDFile(){
	if [ -f $PIDSPATH/PIDFILE ]; then
        	rm -f $PIDSPATH/$PIDFILE
        fi
}

start() {
        log_daemon_msg "Starting $DESCRIPTION"
	
	isRunning
	isAlive=$?
	
        if [ "${isAlive}" -eq $TRUE ]; then
                log_end_msg $SCRIPT_ERROR
        else
                start-stop-daemon --start --quiet --chuid $RUNAS --pidfile $PIDSPATH/$PIDFILE --exec $DAEMON
                setFilePerms
		log_end_msg $SCRIPT_OK
        fi
}

stop() {
	log_daemon_msg "Stopping $DESCRIPTION"
	
	isRunning
	isAlive=$?
        if [ "${isAlive}" -eq $TRUE ]; then
                start-stop-daemon --stop --quiet --pidfile $PIDSPATH/$PIDFILE

		removePIDFile

                log_end_msg $SCRIPT_OK
        else
                log_end_msg $SCRIPT_ERROR
        fi
}

reload() {
	configtest || return $?

	log_daemon_msg "Reloading (via HUP) $DESCRIPTION"

        isRunning
        if [ $? -eq $TRUE ]; then
		`killall -HUP $PS` #to be safe

                log_end_msg $SCRIPT_OK
        else
                log_end_msg $SCRIPT_ERROR
        fi
}

terminate() {
        log_daemon_msg "Force terminating (via KILL) $DESCRIPTION"
        
	PIDS=`pidof $PS` || true

	[ -e $PIDSPATH/$PIDFILE ] && PIDS2=`cat $PIDSPATH/$PIDFILE`

	for i in $PIDS; do
		if [ "$i" = "$PIDS2" ]; then
	        	kill $i
			removePIDFile
		fi
	done

	log_end_msg $SCRIPT_OK

}

pidof_daemon() {
    PIDS=`pidof $PS` || true

    [ -e $PIDSPATH/$PIDFILE ] && PIDS2=`cat $PIDSPATH/$PIDFILE`

    for i in $PIDS; do
        if [ "$i" = "$PIDS2" ]; then
            return 1
        fi
    done
    return 0
}

case "$1" in
  start)
	start
        ;;
  stop)
	stop
        ;;
  restart|force-reload)
	stop
	start
        ;;
  reload)
	$1
	;;
  status)
	status
	;;
  configtest)
        $1
        ;;
  terminate)
	$1
	;;
  *)
	FULLPATH=/etc/init.d/$PIDNAME
	echo "Usage: $FULLPATH {start|stop|restart|force-reload|status|configtest|terminate}"
	exit 1
	;;
esac

exit 0
